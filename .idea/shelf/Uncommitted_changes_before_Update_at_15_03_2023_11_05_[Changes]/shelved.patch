Index: B4_Automata.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from __future__ import annotations\nimport graphviz\nimport tabulate\nimport string\nimport os\nfrom copy import deepcopy\nimport sys\nimport subprocess\nfrom pathlib import Path\n\n\ndef open_image(path):\n    \"\"\"\n    Opens an image in the default viewer for the operating system.\n\n    :param path: Specify the path to the image file\n    :return: Nothing, it just opens the image in your default browser\n    \"\"\"\n    command = {'linux': 'xdg-open',\n               'win32': 'explorer',\n               'darwin': 'open'}[sys.platform]\n    subprocess.Popen([command, Path(path)], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)\n\n\nclass Automata:\n    \"\"\"\n    A class to represent an automata.\n\n    Attributes\n    ----------\n    entrees\n        list of initial states\n\n    exits\n        list of terminal states\n\n    alphabet\n        list of letter making the alphabet of the automata\n\n    source\n        a path for the .txt file the automata will get its transitions\n\n    output\n        the name of the output files\n\n    format\n        the format output (.gif, .png ...)\n\n    transitions\n        the transition dictionary\n        it is composed as such:\n        {\n            'state1' : {\n                'letter1' : [ 'state2', 'state1' ],\n                'letter2' : [ 'state3' ],\n            },\n            'state2' : {\n                'letter1' : [],\n                'letter2' : [ 'state3' ]\n            },\n            'state3' : {\n                'letter1' : [ 'state3' ],\n                'letter2' : [],\n            },\n        }\n    \"\"\"\n\n    def __init__(self, source_file=\"\", output_file=\"automata\", out_type=\"gif\"):\n        self.entrees: list[str] = []\n        self.exits: list[str] = []\n        self.transitions: dict[str, dict[str, list[str]]] = {}\n        self.alphabet: list[str] = []\n\n        self.source: str = source_file\n        self.output: str = output_file\n        self.format: str = out_type\n\n        if source_file:\n            self._populate_from_file_(self.source)\n\n    def __str__(self):\n        headers = [\"E/S\", \"État\"] + self.alphabet\n        table = [\n            [\n                self._give_state_behaviour_(k),\n                k,\n            ] + [','.join(self._fetch_transition_(k, x)) for x in self.alphabet]\n            for k in self.transitions.keys()]\n\n        return tabulate.tabulate(table, headers, tablefmt=\"rounded_grid\")\n\n    def __repr__(self):\n        try:\n            os.mkdir(\"out\")\n            os.mkdir(\"dot\")\n        except OSError:\n            pass\n        else:\n            pass\n\n        graphviz.Source(self.to_dot_format()) \\\n            .render(filename=Path(f'dot/{self.output}.dot'), outfile=Path(f'out/{self.output}.{self.format}'), view=False)\n\n        open_image(Path(f'out/{self.output}.{self.format}'))\n\n        return ''\n\n    def __eq__(self, other):\n        return self.transitions == other.transitions \\\n            and self.entrees == other.entrees \\\n            and self.exits == other.exists\n\n    def __len__(self):\n        return len(self.transitions.keys())\n\n    def _give_state_behaviour_(self, state: str, arrows: bool = True) -> str:\n        \"\"\"\n        Returns an indication of the initial or/and terminal behaviour of a state.\n\n        :param self: Refer to the object itself\n        :param state: str: Indicate the state to analyse\n        :param arrows: bool: Indicate whether the fancy notation or with letters should be used\n        :return: An indication of initial or/and terminal behaviour of the state\n        \"\"\"\n        if state in self.entrees and state in self.exits:\n            return '<-->' if arrows else 'E S'\n\n        if state in self.entrees:\n            return '-->' if arrows else 'E'\n\n        if state in self.exits:\n            return '<--' if arrows else 'S'\n\n        return ''\n\n    def _fetch_transition_(self, state: str, letter: str) -> list[str]:\n        \"\"\"\n        Returns the list of states that are in the transition dict for a given state and letter.\n        If there is no such state, it will return an empty list.\n\n        :param self: Represent the instance of the class\n        :param state: str: The state\n        :param letter: str: Get the letter that is being used to transition from one state to another\n        :return: A list of states the state is going to with the letter\n        \"\"\"\n        return self.transitions.get(state).get(letter) or []\n\n    def _populate_from_file_(self, path: str) -> dict[str, dict[str, list[str]]]:\n        \"\"\"\n        Fills the transition dict with a .txt file.\n\n        :param self: Refer to the object itself\n        :param path: str: Get the path of the file\n        :return: The `self.transitions` dict\n        \"\"\"\n        with open(path, 'r') as f:\n            fa_data = f.readlines()\n\n            self.alphabet = list(string.ascii_lowercase[:int(fa_data[0])])\n\n            self.entrees = fa_data[2][:-1].split(' ')[1:]\n            self.exits = fa_data[3][:-1].split(' ')[1:]\n\n            for line in fa_data[5:]:\n                line = line[:-1] if line[-1] == '\\n' else line\n                state = ''\n                pos = 0\n                for i, val in enumerate(line):\n                    if val in string.ascii_letters + 'ε':\n                        pos = i\n                        break\n                    state += val\n\n                if self.transitions.get(state):\n                    if self._fetch_transition_(state, line[pos]):\n                        self.transitions[state][line[pos]].append(line[pos + 1:])\n                        self.transitions[state][line[pos]].sort()\n                    else:\n                        self.transitions[state][line[pos]] = [line[pos + 1:]]\n                else:\n                    self.transitions[state] = {line[pos]: [line[pos + 1:]]}\n\n        # if I modify self.transitions directly it changes the size of the iter and breaks\n        # it is equivalent ot a temp variable\n        i_dont_want_to_break_things: dict[str, dict[str, list[str]]] = {}\n\n        for i in self.entrees:\n            if i not in self.transitions.keys():\n                i_dont_want_to_break_things[i] = {letter: [] for letter in self.alphabet}\n\n        for i in self.exits:\n            if i not in self.transitions.keys():\n                i_dont_want_to_break_things[i] = {letter: [] for letter in self.alphabet}\n\n        for state, transitions in self.transitions.items():\n            for letter, states in transitions.items():\n                for i in states:\n                    if i not in self.transitions.keys():\n                        i_dont_want_to_break_things[i] = {letter: [] for letter in self.alphabet}\n\n        self.transitions |= i_dont_want_to_break_things\n\n        return self.transitions\n\n    def _different_transitions_dict_(self) -> dict[str, dict[str, list]]:\n        \"\"\"\n        Takes the transitions dictionary and reorganizes it.\n        The original transitions dictionary has the following structure:\n        {\n            'state' : {\n                'letter' : [ 'state', ... ],  # The list of states can be empty, but there will always be at least one letter key.\n                ...                           # There may also be multiple letters for each state in this list.  This is why we need to reorganize it!\n\n        :param self: Access the attributes of the class\n        :return: A dictionary with the states as keys and a dictionary of transitions from that state as values\n        \"\"\"\n        dic = {}\n        for state, transitions in self.transitions.items():\n            dic[state] = {}\n            for k, v in transitions.items():\n                for i in v:\n                    if dic[state].get(i):\n                        dic[state][i].append(k)\n                    else:\n                        dic[state][i] = [k]\n        return dic\n\n    def _state_is_empty_(self, state: str, letter: str) -> bool:\n        \"\"\"\n        Checks if a state is empty.\n\n        :param self: Access the attributes of the class\n        :param state: str: Determine the state that is being checked\n        :param letter: str: Check if the transition is empty\n        :return: True if the state is empty\n        \"\"\"\n        return not self._fetch_transition_(state, letter) \\\n            or self._fetch_transition_(state, letter) == ['']\n\n    def get_info(self):\n        \"\"\"\n        Returns a string containing the following information:\n            - The number of transitions in the automaton.\n            - Whether it is standard, determinate and complete.\n            - The alphabet used by the automaton.\n\n        :param self: Refer to the current object\n        :return: A string containing the information of the automaton\n        \"\"\"\n        headers = [\"Standard\", \"Détérminé\", \"Complet\", \"transitions\", \"n°entrée\", \"n°sortie\"]\n        table = [[\n            str(self.is_standard()),\n            str(self.is_determinate()),\n            str(self.is_complete()),\n            str(len(self)),\n            str(len(self.entrees)),\n            str(len(self.exits))\n        ]]\n\n        return f\"{tabulate.tabulate(table, headers, tablefmt='rounded_grid')}\\n\" \\\n               f\"{tabulate.tabulate([['{' + ', '.join(self.alphabet) + '}']], ['Alphabet'], tablefmt='rounded_grid')}\"\n\n    def is_e_nfa(self) -> bool:\n        \"\"\"\n        Checks if the NFA is an epsilon-NFA.\n\n        :param self: Access the attributes of the class\n        :return: True if the machine has an epsilon transition\n        \"\"\"\n        for state, transitions in self.transitions.items():\n            for trans in transitions:\n                if 'E' in trans or 'ε' in trans:\n                    return True\n\n        return False\n\n    def to_dot_format(self) -> str:\n        \"\"\"\n        Converts the finite state machine into a dot format.\n\n        :param self: Refer to the current instance of a class\n        :return: A string in the dot format, which can be used to display the automaton graphically\n        \"\"\"\n        to_dot = \"digraph finite_state_machine { rankdir=LR\\n\"\n\n        to_dot += \"\\tnode [shape=doublecircle]\\n\"\n        for exit_ in self.exits:\n            to_dot += f\"\\t\\\"{exit_}\\\"\\n\"\n\n        to_dot += '\\n'\n\n        to_dot += \"\\tnode [shape=circle]\\n\"\n        for idx, entree in enumerate(self.entrees):\n            to_dot += f\"\\tfake{str(idx)} [style=invisible]\\n\\tfake{str(idx)} -> \\\"{entree}\\\"\\n\"\n\n        to_dot += '\\n'\n\n        for state, transitions in self._different_transitions_dict_().items():\n            for k, v in transitions.items():\n                if k:\n                    to_dot += f\"\\t\\\"{state}\\\" -> \\\"{k}\\\" [label=\\\"{str(', '.join(v))}\\\"] \\n\"\n\n        to_dot += \"}\"\n        return to_dot\n\n    def is_standard(self) -> bool:\n        \"\"\"\n        Checks if the automaton is standard.\n\n        :param self: Refer to the object itself\n        :return: True if the automaton is standard, and false otherwise\n        \"\"\"\n        if len(self.entrees) != 1:\n            return False\n\n        for transitions in self.transitions.values():\n            for transition in transitions:\n                if self.entrees[0] in transition:\n                    return False\n\n        return True\n\n    def get_standard(self) -> Automata:\n        \"\"\"\n        Transforms a non-standard automata into a standard one.\n\n        :param self: Refer to the instance of the class\n        :return: A standard automaton\n        \"\"\"\n        if self.is_standard():\n            return self\n\n        standard = deepcopy(self)\n        dic = {}\n        for i in [standard.transitions.get(x) for x in standard.entrees]:\n            for k, v in i.items():\n                if dic.get(k):\n                    dic[k] += v\n                else:\n                    dic[k] = v\n                dic[k] = list(set(dic[k]))\n\n        standard.transitions['I'] = dic\n        standard.entrees = ['I']\n\n        return standard\n\n    def is_complete(self) -> bool:\n        \"\"\"\n        Checks if the automata is complete.\n\n        :param self: Represent the instance of the class\n        :return: A boolean value\n        \"\"\"\n        for state in self.transitions.keys():\n            for letter in self.alphabet:\n                if self._state_is_empty_(state, letter):\n                    return False\n        return True\n\n    def get_complete(self) -> Automata:\n        \"\"\"\n        Takes an automata and returns a complete version of it.\n            If the automata is already complete, then it will return itself.\n\n        :param self: Refer to the current object\n        :return: A complete automata\n        \"\"\"\n        if self.is_complete():\n            return self\n\n        complete = deepcopy(self)\n        garbage = {letter: ['P'] for letter in self.alphabet}\n\n        complete.transitions['P'] = garbage\n\n        for state in self.transitions.keys():\n            for letter in self.alphabet:\n                if self._state_is_empty_(state, letter):\n                    complete.transitions[state][letter] = ['P']\n\n        return complete\n\n    def is_determinate(self) -> bool:\n        \"\"\"\n        Checks if the automaton is determinate.\n\n        :param self: Refer to the object itself\n        :return: A boolean value that indicates whether the automaton is determinate\n        \"\"\"\n        if len(self.entrees) != 1:\n            return False\n\n        for transition in self.transitions.values():\n            for states in transition.values():\n                if len(states) > 1:\n                    return False\n\n        return True\n\n    def get_determinized(self, step: bool = False) -> Automata | list[Automata]:\n        \"\"\"\n        Takes an automata and returns a new automata that is equivalent to the original but is determinate.\n\n        Clarifications :\n        This function works by first creating a new automata with the same alphabet as the original,\n        and then adding all the states from the original to this new one.\n        The transitions are then added in such a way that they are deterministic\n        (i.e., there can only be one transition for each letter).\n\n        If there were multiple possible transitions for any given letter,\n        these transitions will be combined into one state which contains all of them.\n\n        :param self: Access the attributes of the class\n        :param step: bool: Determine if the function should return a list of automatas or just one\n        :return: A list of automata objects if step is true, otherwise it returns a single automata object\n        \"\"\"\n        if self.is_e_nfa():\n            return self\n\n        if self.is_determinate():\n            if self.is_complete():\n                if step:\n                    return [self]\n                return self\n            else:\n                if step:\n                    return [self.get_complete()]\n                return self.get_complete()\n\n        steps: list[Automata] = []\n\n        determinate = Automata()\n        determinate.alphabet = self.alphabet.copy()\n\n        # unite the entrees\n        new_entree = {}\n        for state in self.entrees:\n            for letter in self.transitions.get(state):\n                if new_entree.get(letter):\n                    new_entree[letter] += self._fetch_transition_(state, letter).copy()\n                else:\n                    new_entree[letter] = self._fetch_transition_(state, letter).copy()\n\n                new_entree[letter] = sorted(list(set(new_entree[letter])))\n\n        for letter, to_state in new_entree.items():\n            new_entree[letter] = ['-'.join(to_state)]\n\n        new_entree = {'-'.join(self.entrees): new_entree}\n\n        ###\n\n        # populate the transitions dict\n        determinate.entrees = list(new_entree.keys())\n        determinate.exits = []\n\n        for state in self.entrees:\n            if state in self.exits:\n                determinate.exits.append('-'.join(self.entrees))\n\n        determinate.transitions = deepcopy(new_entree)\n\n        if step:\n            steps.append(deepcopy(determinate))\n\n        state_buffer = []\n        for composing_states in new_entree.values():\n            for joined_states in composing_states.values():\n                state_buffer += joined_states\n\n        state_buffer = list(set(state_buffer))\n\n        while state_buffer:\n            cur_state = state_buffer.pop()\n\n            det_tr = determinate.transitions\n\n            det_tr[cur_state] = {}\n\n            if self.transitions.get(cur_state):\n                letter: str\n                for letter, to_state in self.transitions.get(cur_state).items():\n                    det_tr[cur_state][letter] = ['-'.join(to_state)]\n\n                if cur_state in self.exits:\n                    determinate.exits.append(cur_state)\n\n            elif not det_tr.get(cur_state):\n                composing_states = list(set(cur_state.split('-')))\n\n                for receiving_state in composing_states:\n                    if receiving_state in self.exits:\n                        determinate.exits.append(cur_state)\n\n                for letter in determinate.alphabet:\n                    det_tr.get(cur_state)[letter] = []\n\n                for state in composing_states:\n                    for letter, to_state in self.transitions.get(state).items():\n                        temp = det_tr.get(cur_state).get(letter)\n                        temp += to_state\n                        det_tr.get(cur_state)[letter] = list(set(temp))\n\n            for composing_states in det_tr.get(cur_state).values():\n                joined_states = '-'.join(sorted(composing_states))\n                if joined_states and (joined_states not in det_tr.keys()) and joined_states not in state_buffer:\n                    state_buffer.append(joined_states)\n\n            for letter, to_state in det_tr.get(cur_state).items():\n                to_state = sorted(list(set(to_state)))\n                det_tr.get(cur_state)[letter] = ['-'.join(to_state)]\n\n            if step:\n                steps.append(deepcopy(determinate))\n\n        if step:\n            return steps + [determinate.get_complete()]\n\n        return determinate.get_complete()\n\n    # BONUS #\n\n    def test_word(self, word) -> bool:\n        \"\"\"\n        Takes a word as an argument and returns True if the word is accepted by the automaton, and False otherwise.\n\n        :param self: Bind the method to an object\n        :param word: Test the word on the automaton\n        :return: True if the word is accepted by the automaton and false otherwise\n        \"\"\"\n        if False in [letter in self.alphabet + ['E', 'ε'] for letter in word]:\n            return False\n\n        if not self.is_determinate():\n            return False\n\n        cur_state = self.entrees[0]\n\n        for i, letter in enumerate(word):\n            # print(cur_state)\n            next_state = self._fetch_transition_(cur_state, letter)[0]\n\n            cur_state = next_state\n\n        if cur_state in self.exits:\n            return True\n\n        return False\n\n    def get_minimized(self):\n        ...\n\n    def get_complementary(self):\n        \"\"\"\n        Returns a new DFA that accepts the complement of the language accepted by this DFA.\n        The complement is defined as all strings not in the language.\n\n\n        :param self: Access the attributes of the class\n        :return: The complementary of the automaton\n        \"\"\"\n        complementary = deepcopy(self.get_determinized())\n\n        non_exits = [state for state in complementary.transitions.keys() if state not in complementary.exits]\n\n        complementary.exits = non_exits.copy()\n\n        return complementary\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/B4_Automata.py b/B4_Automata.py
--- a/B4_Automata.py	(revision 1a5bada9db8566891610bf2dfcfa4b24b9e8ab74)
+++ b/B4_Automata.py	(date 1678874331655)
@@ -398,6 +398,9 @@
 
         return True
 
+    def get_state_e_closure(self, state):
+        ...
+
     def get_determinized(self, step: bool = False) -> Automata | list[Automata]:
         """
         Takes an automata and returns a new automata that is equivalent to the original but is determinate.
Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project version=\"4\">\n  <component name=\"AutoImportSettings\">\n    <option name=\"autoReloadType\" value=\"SELECTIVE\" />\n  </component>\n  <component name=\"ChangeListManager\">\n    <list default=\"true\" id=\"3e241f03-ef69-4427-9b99-2083bececcc5\" name=\"Changes\" comment=\"Documentations\">\n      <change beforePath=\"$PROJECT_DIR$/B4_Application.py\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/B4_Application.py\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/B4_Automata.py\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/B4_Automata.py\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/B4_AutomataAnimation.py\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/B4_AutomataAnimation.py\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/anim/automata/strandardize.gif\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/anim/automata/strandardize.gif\" afterDir=\"false\" />\n    </list>\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\n  </component>\n  <component name=\"FileTemplateManagerImpl\">\n    <option name=\"RECENT_TEMPLATES\">\n      <list>\n        <option value=\"Python Script\" />\n      </list>\n    </option>\n  </component>\n  <component name=\"FlaskConsoleOptions\" custom-start-script=\"import sys&#10;sys.path.extend([WORKING_DIR_AND_PYTHON_PATHS])&#10;from flask.cli import ScriptInfo&#10;locals().update(ScriptInfo(create_app=None).load_app().make_shell_context())&#10;print(&quot;Python %s on %s\\nApp: %s [%s]\\nInstance: %s&quot; % (sys.version, sys.platform, app.import_name, app.env, app.instance_path))\">\n    <envs>\n      <env key=\"FLASK_APP\" value=\"app\" />\n    </envs>\n    <option name=\"myCustomStartScript\" value=\"import sys&#10;sys.path.extend([WORKING_DIR_AND_PYTHON_PATHS])&#10;from flask.cli import ScriptInfo&#10;locals().update(ScriptInfo(create_app=None).load_app().make_shell_context())&#10;print(&quot;Python %s on %s\\nApp: %s [%s]\\nInstance: %s&quot; % (sys.version, sys.platform, app.import_name, app.env, app.instance_path))\" />\n    <option name=\"myEnvs\">\n      <map>\n        <entry key=\"FLASK_APP\" value=\"app\" />\n      </map>\n    </option>\n  </component>\n  <component name=\"Git.Settings\">\n    <option name=\"RECENT_BRANCH_BY_REPOSITORY\">\n      <map>\n        <entry key=\"$PROJECT_DIR$\" value=\"minimizing\" />\n      </map>\n    </option>\n  </component>\n  <component name=\"MarkdownSettingsMigration\">\n    <option name=\"stateVersion\" value=\"1\" />\n  </component>\n  <component name=\"ProjectId\" id=\"2M9sahcLeP1MercG1txHq3vXhJ2\" />\n  <component name=\"ProjectLevelVcsManager\" settingsEditedManually=\"true\" />\n  <component name=\"ProjectViewState\">\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\n    <option name=\"showLibraryContents\" value=\"true\" />\n  </component>\n  <component name=\"PropertiesComponent\">{\n  &quot;keyToString&quot;: {\n    &quot;ASKED_SHARE_PROJECT_CONFIGURATION_FILES&quot;: &quot;true&quot;,\n    &quot;RunOnceActivity.OpenProjectViewOnStart&quot;: &quot;true&quot;,\n    &quot;RunOnceActivity.ShowReadmeOnStart&quot;: &quot;true&quot;,\n    &quot;SHARE_PROJECT_CONFIGURATION_FILES&quot;: &quot;true&quot;,\n    &quot;WebServerToolWindowFactoryState&quot;: &quot;false&quot;,\n    &quot;node.js.detected.package.eslint&quot;: &quot;true&quot;,\n    &quot;node.js.detected.package.tslint&quot;: &quot;true&quot;,\n    &quot;node.js.selected.package.eslint&quot;: &quot;(autodetect)&quot;,\n    &quot;node.js.selected.package.tslint&quot;: &quot;(autodetect)&quot;,\n    &quot;nodejs_package_manager_path&quot;: &quot;npm&quot;,\n    &quot;settings.editor.selected.configurable&quot;: &quot;Errors&quot;,\n    &quot;settings.editor.splitter.proportion&quot;: &quot;0.30692077&quot;,\n    &quot;vue.rearranger.settings.migration&quot;: &quot;true&quot;\n  },\n  &quot;keyToStringList&quot;: {\n    &quot;com.intellij.ide.scratch.ScratchImplUtil$2/New Scratch File&quot;: [\n      &quot;PLAIN_TEXT&quot;\n    ]\n  }\n}</component>\n  <component name=\"RecentsManager\">\n    <key name=\"MoveFile.RECENT_KEYS\">\n      <recent name=\"$PROJECT_DIR$/automaton\" />\n    </key>\n  </component>\n  <component name=\"RunManager\" selected=\"Python.tests\">\n    <configuration name=\"B4_Application\" type=\"PythonConfigurationType\" factoryName=\"Python\" temporary=\"true\" nameIsGenerated=\"true\">\n      <module name=\"L2FiniteAutomaton\" />\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\n      <option name=\"PARENT_ENVS\" value=\"true\" />\n      <envs>\n        <env name=\"PYTHONUNBUFFERED\" value=\"1\" />\n      </envs>\n      <option name=\"SDK_HOME\" value=\"\" />\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$\" />\n      <option name=\"IS_MODULE_SDK\" value=\"true\" />\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\n      <EXTENSION ID=\"PythonCoverageRunConfigurationExtension\" runner=\"coverage.py\" />\n      <option name=\"SCRIPT_NAME\" value=\"$PROJECT_DIR$/B4_Application.py\" />\n      <option name=\"PARAMETERS\" value=\"\" />\n      <option name=\"SHOW_COMMAND_LINE\" value=\"false\" />\n      <option name=\"EMULATE_TERMINAL\" value=\"false\" />\n      <option name=\"MODULE_MODE\" value=\"false\" />\n      <option name=\"REDIRECT_INPUT\" value=\"false\" />\n      <option name=\"INPUT_FILE\" value=\"\" />\n      <method v=\"2\" />\n    </configuration>\n    <configuration name=\"B4_main\" type=\"PythonConfigurationType\" factoryName=\"Python\" nameIsGenerated=\"true\">\n      <module name=\"L2FiniteAutomaton\" />\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\n      <option name=\"PARENT_ENVS\" value=\"true\" />\n      <envs>\n        <env name=\"PYTHONUNBUFFERED\" value=\"1\" />\n      </envs>\n      <option name=\"SDK_HOME\" value=\"/usr/bin/python3.10\" />\n      <option name=\"SDK_NAME\" value=\"/usr/bin/python3.10\" />\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$\" />\n      <option name=\"IS_MODULE_SDK\" value=\"false\" />\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\n      <EXTENSION ID=\"PythonCoverageRunConfigurationExtension\" runner=\"coverage.py\" />\n      <option name=\"SCRIPT_NAME\" value=\"$PROJECT_DIR$/B4_main.py\" />\n      <option name=\"PARAMETERS\" value=\"\" />\n      <option name=\"SHOW_COMMAND_LINE\" value=\"false\" />\n      <option name=\"EMULATE_TERMINAL\" value=\"false\" />\n      <option name=\"MODULE_MODE\" value=\"false\" />\n      <option name=\"REDIRECT_INPUT\" value=\"false\" />\n      <option name=\"INPUT_FILE\" value=\"\" />\n      <method v=\"2\" />\n    </configuration>\n    <configuration name=\"tests\" type=\"PythonConfigurationType\" factoryName=\"Python\">\n      <module name=\"L2FiniteAutomaton\" />\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\n      <option name=\"PARENT_ENVS\" value=\"true\" />\n      <envs>\n        <env name=\"PYTHONUNBUFFERED\" value=\"1\" />\n      </envs>\n      <option name=\"SDK_HOME\" value=\"/usr/bin/python3.10\" />\n      <option name=\"SDK_NAME\" value=\"/usr/bin/python3.10\" />\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$\" />\n      <option name=\"IS_MODULE_SDK\" value=\"false\" />\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\n      <EXTENSION ID=\"PythonCoverageRunConfigurationExtension\" runner=\"coverage.py\" />\n      <option name=\"SCRIPT_NAME\" value=\"$PROJECT_DIR$/tests.py\" />\n      <option name=\"PARAMETERS\" value=\"\" />\n      <option name=\"SHOW_COMMAND_LINE\" value=\"false\" />\n      <option name=\"EMULATE_TERMINAL\" value=\"false\" />\n      <option name=\"MODULE_MODE\" value=\"false\" />\n      <option name=\"REDIRECT_INPUT\" value=\"false\" />\n      <option name=\"INPUT_FILE\" value=\"\" />\n      <method v=\"2\" />\n    </configuration>\n    <list>\n      <item itemvalue=\"Python.B4_main\" />\n      <item itemvalue=\"Python.tests\" />\n      <item itemvalue=\"Python.B4_Application\" />\n    </list>\n    <recent_temporary>\n      <list>\n        <item itemvalue=\"Python.B4_Application\" />\n        <item itemvalue=\"Python.B4_Application\" />\n        <item itemvalue=\"Python.B4_Application\" />\n      </list>\n    </recent_temporary>\n  </component>\n  <component name=\"SpellCheckerSettings\" RuntimeDictionaries=\"0\" Folders=\"0\" CustomDictionaries=\"0\" DefaultDictionary=\"application-level\" UseSingleDictionary=\"true\" transferred=\"true\" />\n  <component name=\"TaskManager\">\n    <task active=\"true\" id=\"Default\" summary=\"Default task\">\n      <changelist id=\"3e241f03-ef69-4427-9b99-2083bececcc5\" name=\"Changes\" comment=\"\" />\n      <created>1677191197776</created>\n      <option name=\"number\" value=\"Default\" />\n      <option name=\"presentableId\" value=\"Default\" />\n      <updated>1677191197776</updated>\n      <workItem from=\"1677191198911\" duration=\"67000\" />\n      <workItem from=\"1677191276018\" duration=\"70000\" />\n      <workItem from=\"1677191355614\" duration=\"46000\" />\n      <workItem from=\"1677191408112\" duration=\"27811000\" />\n      <workItem from=\"1677238301248\" duration=\"1407000\" />\n      <workItem from=\"1677240273293\" duration=\"37000000\" />\n      <workItem from=\"1677402594164\" duration=\"10460000\" />\n      <workItem from=\"1677507580516\" duration=\"16168000\" />\n      <workItem from=\"1677573880756\" duration=\"9548000\" />\n      <workItem from=\"1677835796168\" duration=\"5886000\" />\n      <workItem from=\"1677948065030\" duration=\"622000\" />\n      <workItem from=\"1678031935119\" duration=\"12342000\" />\n      <workItem from=\"1678090437940\" duration=\"18883000\" />\n      <workItem from=\"1678133741763\" duration=\"4787000\" />\n      <workItem from=\"1678179975870\" duration=\"5304000\" />\n      <workItem from=\"1678195125107\" duration=\"6080000\" />\n      <workItem from=\"1678212187239\" duration=\"2444000\" />\n      <workItem from=\"1678265115200\" duration=\"11886000\" />\n      <workItem from=\"1678308870966\" duration=\"44514000\" />\n      <workItem from=\"1678480552747\" duration=\"1237000\" />\n    </task>\n    <task id=\"LOCAL-00001\" summary=\"added main loop, better formating\">\n      <created>1677231392963</created>\n      <option name=\"number\" value=\"00001\" />\n      <option name=\"presentableId\" value=\"LOCAL-00001\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1677231392963</updated>\n    </task>\n    <task id=\"LOCAL-00002\" summary=\"tests.py added, fixed bugs in populate and double arrow bug fixed\">\n      <created>1677237912452</created>\n      <option name=\"number\" value=\"00002\" />\n      <option name=\"presentableId\" value=\"LOCAL-00002\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1677237912452</updated>\n    </task>\n    <task id=\"LOCAL-00003\" summary=\"gitignore\">\n      <created>1677238446772</created>\n      <option name=\"number\" value=\"00003\" />\n      <option name=\"presentableId\" value=\"LOCAL-00003\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1677238446772</updated>\n    </task>\n    <task id=\"LOCAL-00004\" summary=\"gitignore\">\n      <created>1677238473913</created>\n      <option name=\"number\" value=\"00004\" />\n      <option name=\"presentableId\" value=\"LOCAL-00004\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1677238473913</updated>\n    </task>\n    <task id=\"LOCAL-00005\" summary=\"gitignore\">\n      <created>1677238507269</created>\n      <option name=\"number\" value=\"00005\" />\n      <option name=\"presentableId\" value=\"LOCAL-00005\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1677238507269</updated>\n    </task>\n    <task id=\"LOCAL-00006\" summary=\"gitignore\">\n      <created>1677238592185</created>\n      <option name=\"number\" value=\"00006\" />\n      <option name=\"presentableId\" value=\"LOCAL-00006\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1677238592185</updated>\n    </task>\n    <task id=\"LOCAL-00007\" summary=\"I finally probably did it, good lord help me\">\n      <created>1677260923515</created>\n      <option name=\"number\" value=\"00007\" />\n      <option name=\"presentableId\" value=\"LOCAL-00007\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1677260923515</updated>\n    </task>\n    <task id=\"LOCAL-00008\" summary=\"additional changes, `self.transition` changed and printing fixed\">\n      <created>1677511996627</created>\n      <option name=\"number\" value=\"00008\" />\n      <option name=\"presentableId\" value=\"LOCAL-00008\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1677511996627</updated>\n    </task>\n    <task id=\"LOCAL-00009\" summary=\"still broken, but better\">\n      <created>1677948087127</created>\n      <option name=\"number\" value=\"00009\" />\n      <option name=\"presentableId\" value=\"LOCAL-00009\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1677948087127</updated>\n    </task>\n    <task id=\"LOCAL-00010\" summary=\"determinize finished and working\">\n      <created>1678038493293</created>\n      <option name=\"number\" value=\"00010\" />\n      <option name=\"presentableId\" value=\"LOCAL-00010\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1678038493293</updated>\n    </task>\n    <task id=\"LOCAL-00011\" summary=\"determinized fixed + animation\">\n      <created>1678126362024</created>\n      <option name=\"number\" value=\"00011\" />\n      <option name=\"presentableId\" value=\"LOCAL-00011\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1678126362024</updated>\n    </task>\n    <task id=\"LOCAL-00012\" summary=\"delete unused files\">\n      <created>1678126687174</created>\n      <option name=\"number\" value=\"00012\" />\n      <option name=\"presentableId\" value=\"LOCAL-00012\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1678126687174</updated>\n    </task>\n    <task id=\"LOCAL-00013\" summary=\"fixed dot formatting bug\">\n      <created>1678144925133</created>\n      <option name=\"number\" value=\"00013\" />\n      <option name=\"presentableId\" value=\"LOCAL-00013\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1678144925133</updated>\n    </task>\n    <task id=\"LOCAL-00014\" summary=\"fixed dot formatting bug 2\">\n      <created>1678146152492</created>\n      <option name=\"number\" value=\"00014\" />\n      <option name=\"presentableId\" value=\"LOCAL-00014\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1678146152492</updated>\n    </task>\n    <task id=\"LOCAL-00015\" summary=\"starting curses application\">\n      <created>1678222921976</created>\n      <option name=\"number\" value=\"00015\" />\n      <option name=\"presentableId\" value=\"LOCAL-00015\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1678222921976</updated>\n    </task>\n    <task id=\"LOCAL-00016\" summary=\"Probably finished app\">\n      <created>1678286888880</created>\n      <option name=\"number\" value=\"00016\" />\n      <option name=\"presentableId\" value=\"LOCAL-00016\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1678286888880</updated>\n    </task>\n    <task id=\"LOCAL-00017\" summary=\"Basic App (could have upgrade)\">\n      <created>1678381092975</created>\n      <option name=\"number\" value=\"00017\" />\n      <option name=\"presentableId\" value=\"LOCAL-00017\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1678381092975</updated>\n    </task>\n    <task id=\"LOCAL-00018\" summary=\"word testing implimented v1\">\n      <created>1678386895471</created>\n      <option name=\"number\" value=\"00018\" />\n      <option name=\"presentableId\" value=\"LOCAL-00018\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1678386895471</updated>\n    </task>\n    <task id=\"LOCAL-00019\" summary=\"word testing implemented v1\">\n      <created>1678386997880</created>\n      <option name=\"number\" value=\"00019\" />\n      <option name=\"presentableId\" value=\"LOCAL-00019\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1678386997880</updated>\n    </task>\n    <task id=\"LOCAL-00020\" summary=\"Documentations\">\n      <created>1678626278696</created>\n      <option name=\"number\" value=\"00020\" />\n      <option name=\"presentableId\" value=\"LOCAL-00020\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1678626278696</updated>\n    </task>\n    <option name=\"localTasksCounter\" value=\"21\" />\n    <servers />\n  </component>\n  <component name=\"TypeScriptGeneratedFilesManager\">\n    <option name=\"version\" value=\"3\" />\n  </component>\n  <component name=\"Vcs.Log.Tabs.Properties\">\n    <option name=\"TAB_STATES\">\n      <map>\n        <entry key=\"MAIN\">\n          <value>\n            <State />\n          </value>\n        </entry>\n      </map>\n    </option>\n  </component>\n  <component name=\"VcsManagerConfiguration\">\n    <MESSAGE value=\"added main loop, better formating\" />\n    <MESSAGE value=\"tests.py added, fixed bugs in populate and double arrow bug fixed\" />\n    <MESSAGE value=\"gitignore\" />\n    <MESSAGE value=\"I finally probably did it, good lord help me\" />\n    <MESSAGE value=\"additional changes, `self.transition` changed and printing fixed\" />\n    <MESSAGE value=\"still broken, but better\" />\n    <MESSAGE value=\"determinize finished and working\" />\n    <MESSAGE value=\"determinized fixed + animation\" />\n    <MESSAGE value=\"delete unused files\" />\n    <MESSAGE value=\"fixed dot formatting bug\" />\n    <MESSAGE value=\"fixed dot formatting bug 2\" />\n    <MESSAGE value=\"starting curses application\" />\n    <MESSAGE value=\"Probably finished app\" />\n    <MESSAGE value=\"Basic App (could have upgrade)\" />\n    <MESSAGE value=\"word testing implimented v1\" />\n    <MESSAGE value=\"word testing implemented v1\" />\n    <MESSAGE value=\"Documentations\" />\n    <option name=\"LAST_COMMIT_MESSAGE\" value=\"Documentations\" />\n  </component>\n  <component name=\"XDebuggerManager\">\n    <breakpoint-manager>\n      <default-breakpoints>\n        <breakpoint type=\"python-exception\">\n          <properties notifyOnTerminate=\"true\" exception=\"BaseException\">\n            <option name=\"notifyOnTerminate\" value=\"true\" />\n          </properties>\n        </breakpoint>\n      </default-breakpoints>\n    </breakpoint-manager>\n  </component>\n  <component name=\"com.intellij.coverage.CoverageDataManagerImpl\">\n    <SUITE FILE_PATH=\"coverage/L2FiniteAutomaton$main.coverage\" NAME=\"main Coverage Results\" MODIFIED=\"1678197259341\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"true\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$\" />\n    <SUITE FILE_PATH=\"coverage/L2FiniteAutomaton$Application.coverage\" NAME=\"Application Coverage Results\" MODIFIED=\"1678282580636\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"true\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$\" />\n    <SUITE FILE_PATH=\"coverage/L2FiniteAutomaton$tests.coverage\" NAME=\"tests Coverage Results\" MODIFIED=\"1678468123971\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"true\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$\" />\n  </component>\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/workspace.xml b/.idea/workspace.xml
--- a/.idea/workspace.xml	(revision 1a5bada9db8566891610bf2dfcfa4b24b9e8ab74)
+++ b/.idea/workspace.xml	(date 1678874720198)
@@ -5,10 +5,8 @@
   </component>
   <component name="ChangeListManager">
     <list default="true" id="3e241f03-ef69-4427-9b99-2083bececcc5" name="Changes" comment="Documentations">
-      <change beforePath="$PROJECT_DIR$/B4_Application.py" beforeDir="false" afterPath="$PROJECT_DIR$/B4_Application.py" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/B4_Automata.py" beforeDir="false" afterPath="$PROJECT_DIR$/B4_Automata.py" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/B4_AutomataAnimation.py" beforeDir="false" afterPath="$PROJECT_DIR$/B4_AutomataAnimation.py" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/anim/automata/strandardize.gif" beforeDir="false" afterPath="$PROJECT_DIR$/anim/automata/strandardize.gif" afterDir="false" />
     </list>
     <option name="SHOW_DIALOG" value="false" />
     <option name="HIGHLIGHT_CONFLICTS" value="true" />
@@ -378,6 +376,6 @@
   <component name="com.intellij.coverage.CoverageDataManagerImpl">
     <SUITE FILE_PATH="coverage/L2FiniteAutomaton$main.coverage" NAME="main Coverage Results" MODIFIED="1678197259341" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="true" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$" />
     <SUITE FILE_PATH="coverage/L2FiniteAutomaton$Application.coverage" NAME="Application Coverage Results" MODIFIED="1678282580636" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="true" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$" />
-    <SUITE FILE_PATH="coverage/L2FiniteAutomaton$tests.coverage" NAME="tests Coverage Results" MODIFIED="1678468123971" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="true" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$" />
+    <SUITE FILE_PATH="coverage/L2FiniteAutomaton$tests.coverage" NAME="tests Coverage Results" MODIFIED="1678719049652" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="true" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$" />
   </component>
 </project>
\ No newline at end of file
